# 2FA

The module provides possibility to add second factor to the authentication process.

### Enabling 2FA

If the user wants to enable 2FA service generates secret key and recovery code.
The user may authorize secret key in any authenticator app (e.g Google Authenticator).
From that point user has an ability to generate TOTP (time-based one time password).
Service verifies that TOTP generated by the user is valid. If it is service attaches
secret key and recovery code to the user's account.

Recovery code may be used in the future to recover an access to an account in case
user can't provide a valid TOTP (e.g. user lost an access to authenticator app).

### Basic user flows

If the user enabled 2FA the flow of authentication or performing some privileged
action (e. g. payment transaction) would be like this:

**Authentication**

1. User performs `POST` request with credentials:
    * **valid credentials**: proceed to next step
    * **invalid credentials**: reject request
2. Service checks that 2FA is enabled:
    * **enabled**: ask user for TOTP
    * **not enabled**: return `JWT`
3. User get TOTP from mobile phone and passes it to service:
    * **valid TOTP**: return `JWT`
    * **invalid TOTP**: reject request

**Password update**

1. On this step we already know if 2FA is enabled:
    * **not enabled**: ask user for the old password and for the new one
    * **enabled:** ask user for the old password, for the new one and for TOTP
2. User gets TOTP from mobile phone and passes it to the service (along with credentials):
    * **valid TOTP**: proceed request (in case credentials are also valid)
    * **invalid TOTP**: reject request

**Several devices**

Imagine case when user enabled 2FA from one device/browser, disabled from
the other one and now try to perform some privileged action from the first device.
The flow would be like this:

1. Here we still think that 2FA is enabled and asks user for TOTP.
2. User gets TOTP from mobile phone and passes it to the service.
3. Service checks if 2FA is actually enabled and detects that it's disabled now.
4. Service allows to perform an action without verifying TOTP.

And the opposite one. User enabled 2FA from second device:

1. The first device still thinks that 2FA is disabled and allows to perform an action.
2. User performs an action without TOTP.
2. Service checks if 2FA is enabled and detects that it is.
3. Service doesnâ€™t perform an action, returns `403 Forbidden` error and asks user
to perform an action one more time with TOTP provided.

### Disabling 2FA

To disable 2FA user must provides a valid TOTP. In this case service detaches
both secret key and recovery code from user's account. From this point user will
no longer be asked for TOTP during authentication process.

### Actions

* `generateKey` - generates secret key
* `attach` - returns initial recovery code, attaches secret key and recovery code to user's account
* `detach` - detaches secret key and recovery code from user's account (basically disables 2FA)
* `verify` - verifies unless TOTP provided by the user is valid
* `regenerateRecoveryCode` - regenerates recovery code (if the user did provide valid TOTP)

### Errors

`attach`, `detach`, `verify` and `regenerateRecoveryCode` actions require TOTP or
recovery code to be present in either request body or request headers (depends
on transport amqp/http). If TOTP or recovery code are not present the service
returns `403 Forbidden` error with `totp required` message:

```
{
    "error": "Forbidden",
    "message": "totp required",
    "name": "HttpStatusError",
    "statusCode": 403
}
```

In case provided TOTP or recovery code didn't pass verification `verify` action
returns `403 Forbidden` error with `invalid totp` message:

```
{
    "error": "Forbidden",
    "message": "invalid totp",
    "name": "HttpStatusError",
    "statusCode": 403
}
```
